--- LANSCII

- Autores:
  Manuel Pacheco - 10-10524
  Nicolás Mañan - 06-39883

-- Decisiones de Implementacion:

-- Etapa 1: Lexer
1. Lenguaje: decidimos usar Haskell por las facilidades que ofrece así
como el reto funcional que igualmente trae. Sin embargo, el codigo resultante
ha terminado siendo sencillo (salvo algunas expresiones regulares)

2. Tipo de datos del token: esta formado por el tipo de token, su valor e
informacion de posicion, usando siempre el mismo constructor (fue mas facil bajo
ese modelo)

3. Manejo de errores: para universalidad de nuestras funciones y tipos, todos
los simbolos encontrados en el archivo son considerados tokens. Luego de leer
todos los tokens, si existen tokens de malos caracteres o de malos comentarios,
se filtran apropiadamente para solo imprimir los debidos (funcion TokensFilter).

--- Etapa 2: Parser
1. Modularización: seguimos la recomendacion y el proyecto se divide en varios
archivos
  a. Alex.x: lexer de Alex
  b. Happy.y: parser de Happy
  c. Display.hs: typeclasses propias para impresion
  d. AST.hs: definicion de tipos de datos para el arbol sintactico
  e. Main.hs: programa principal

2. Manejo de errores: no conocemos mucho de Monads (aun) y la implementacion actual
de la rutina de errores (parseError) es hecha sin mucha revision.

-- Etapa 3: SymbolTable
1. Archivos principales de la Etapa: se agregan los archivos SymbolTable.hs, donde
se definen tipos e interfaces de uso de una Tabla de Simbolos (incluyendo impresion);
y SymbolChecking.hs, donde se realiza realmente el procesamiento del AST (esto
incluye problemas de declaracion, y verificaciones de tipos)

2. Monad IO: el uso de tablas de hash obligo a encapsular basicamente todo tipo
de operaciones en el Monad IO. Beneficioso en varios casos (mantener estados) y
dificil en otros.

3. Modificaciones a existentes: una clase extra SDisplay en Display.hs y las
modificaciones necesarias a Main.hs

-- Estado Actual del Proyecto:

Se arreglaron los shift/reduce conflicts (agregar un par de reglas de precedencia)
Se intenta implementar todas los requisitos de esta etapa mas quizá hayan verificaciones
(principalmente de tipo) que por error humano no se colocaron donde se debe.
Además, la impresión no es la mas hermosa (se utilizan los derived show en varios
casos) por razones de tiempo.

-- Problemas Presentes

No nos dio tiempo de indagar de como hacer un archivo de cabal. Requerimos el
paquete hashtables que puede ser instalado con "cabal install hashtables".

-- Comentarios respecto al proyecto

--- Etapa 1: Lexer
No se especifica que hacer con un cerrado de comentarios imcompleto.
Decidimos interpretarlo como un error de comentario.

Este proyecto esta bajo control de versiones en el repositorio PRIVADO
https://github.com/ShadowManu/CI3725_Lanscii , administrado por Manuel Pacheco.

--- Etapa 2: Parser
(Ninguno)

--- Etapa 3: Symbol Table
Esta etapa es en la que mayor cantidad de código he escrito y no era nada facil
mezclandolo con una interfaz de IO y usando HashTables en Haskell. Era factible
realizarlo pero en una cantidad mayor de tiempo (considerando que esta entrega
siendo la mas dificil ha tenido el menor tiempo). Sin embargo, estamos a la
espera de feedback de los mayores errores que pueda tener esta entrega.
